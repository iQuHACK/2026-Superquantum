\documentclass[twocolumn, letterpaper]{article}
\usepackage{authblk}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{quantikz2}
\newtheorem{theorem}{Theorem}

\title{iQuHack 2026: Title}
\author[1]{Adam Godel}
\author[1]{Yebin Song}
\author[1]{Nico Jackson}
\author[1]{Travis Meyer}
\author[1]{Timothy Wright}
\affil[1]{Boston University, Boston, Massachusetts 02215, USA}

\begin{document}

\maketitle
\setcounter{page}{1}
\begin{abstract}
	Placeholder
\end{abstract}

\section{Introduction}
The development and optimization of fault-tolerant quantum circuits has been at the forefront of quantum research in recent years. This weekend at iQuHack, Superquantum tasked us with implementing efficient approximate quantum circuit implementations of unitary gate operators using the Clifford + $T$ gate set, where the latter is by far the most computationally difficult gate to execute and functions as a description of the ``quantumness'' of a circuit.\footnotemark

\footnotetext{Our code is freely available on GitHub at the following link: \texttt{https://github.com/adam-godel/2026-Superquantum}.}

Our approach to implement these unitaries varied widely depending on the operator. Some have symmetries that can be exploited, while others are completely random and require brute-force optimization. Furthermore, there is a subjective tradeoff between minimizing the number of $T$ gates and minimizing the distance between the approximate and the exact unitaries. In this writeup, we present our approaches to implement all eleven operators tasked in our challenge, considering how our implementations can be varied in both of these optimization regimes.

We will begin by establishing some background on quantum computing and circuit theory, then continue by discussing each of our implementations in detail, including our experimental results, and conclude with our reflection and possible future work on these problems.

\section{Background}
A \emph{qubit} is the fundamental bit of information in quantum computing. A \emph{two-qubit quantum state} is represented as
\begin{equation}
	|\psi\rangle = \alpha|00\rangle + \beta|01\rangle + \gamma |10\rangle + \delta|11\rangle,
\end{equation}
where $|\alpha|^2+|\beta|^2+|\gamma|^2+|\delta|^2=1$. A two-qubit quantum state can be acted upon with \emph{quantum gates}, which are represented as unitary matrices $A \in U(4)$ such that $|\psi\rangle \mapsto A|\psi\rangle$, which is a valid two-qubit quantum state. Similarly, one-qubit quantum gates are unitary matrices in $U(2)$.

The following quantum gates are known as the \emph{Clifford gates}\cite{PhysRevA.57.127}:
\begin{align}
	H = \frac{1}{\sqrt{2}}\begin{bmatrix}
 	1 & 1 \\
 	1 & -1
 \end{bmatrix} \:
 S = \begin{bmatrix}
 1 & 0 \\
 0 & i
 \end{bmatrix} \:
 CX &= \begin{bmatrix}
 	1 & 0 & 0 & 0 \\
 	0 & 1 & 0 & 0 \\
 	0 & 0 & 0 & 1 \\
 	0 & 0 & 1 & 0
 \end{bmatrix}
 \end{align}
When combined with the $T$ gate, defined as
\begin{equation}
	T = \begin{bmatrix}
 1 & 0 \\
 0 & e^{i\frac{\pi}{4}}
 \end{bmatrix},
\end{equation}
they form a \emph{universal gate set}\cite{PhysRevA.105.052602}, meaning that any unitary operation can be approximated to arbitrary precision using circuits built with just these four gates.

Moreover, the \emph{Gottesman-Knill theorem}~\cite{PhysRevA.70.052328} shows that the Clifford gates can be simulated in polynomial time on a classical computer. This reduces the ``hardness'' of a quantum circuit to be described in the number of $T$ gates it contains. 

\section{Our Implementations}
We now go through each of the eleven unitaries we implemented during the weekend, and the optimizations we made to leverage both low $T$ gate counts and higher accuracy. We describe the implementations in order, although the difficulty in constructing each implementation varied widely.

\subsection{Controlled-$Y$ Gate}
The \emph{controlled-$Y$ gate} is defined as
\begin{equation}
	CY = \begin{bmatrix}
 	1 & 0 & 0 & 0 \\
 	0 & 1 & 0 & 0 \\
 	0 & 0 & 0 & -i \\
 	0 & 0 & i & 0
 \end{bmatrix}.
\end{equation}
To implement this gate, we consider that $(I \otimes S) CX (I \otimes S^\dagger)=CY$, where the $\dagger$ operator denotes the conjugate transpose. Since we can implement this gate using only Clifford gates, there is no tradeoff---we get high accuracy and no $T$ gate cost.

\subsection{Controlled-$R_y(\pi/7)$ Gate}
The \emph{controlled-$R_y$ gate} is defined as
\begin{equation}
	CR_y(\theta) = \begin{bmatrix}
 	1 & 0 & 0 & 0 \\
 	0 & 1 & 0 & 0 \\
 	0 & 0 & \cos(\theta/2) & -\sin(\theta/2) \\
 	0 & 0 & \sin(\theta/2) & \cos(\theta/2)
 \end{bmatrix}.
\end{equation}
We want to consider the case where $\theta=\pi/7$, which does not map cleanly onto a Clifford + $T$ gate set. Therefore, we have to consider approximations. This is when we developed our central strategy for creating these implementations: \emph{\textbf{modularity}} of gates. 

Suppose we had a $R_y$ gate in our toolbox. If this were the case, we could represent $CR_y(\theta)$ with the following circuit:
\begin{equation}
	\begin{quantikz}
		\lstick{$q_0$} &&\ctrl{1}&&\ctrl{1}& \\
		\lstick{$q_1$} &\gate{R_y(\theta/2)}&\targ{}&\gate{R_y(-\theta/2)}&\targ{}&
	\end{quantikz}
\end{equation}
We know that this is true by considering the state of $q_1$ based on the state of $q_0$. We know that $CR_y(\theta)$ should apply $R_y(\theta)$ if $q_0=|1\rangle$ and do nothing if $q_0=|0\rangle$. In Eq. 7, we can see that if $q_0=|0\rangle$, nothing is done to $q_1$, while if $q_0=|1\rangle$, we can see that a $R_y(\theta)$ gate is applied to $q_1$.

The problem now reduces to an implementation of $R_y(\theta)$. We can observe that since $SXS^\dagger=Y$ and $HZH=X$, we have $R_y(\theta)=SHR_z(\theta)HS^\dagger$, i.e. we can represent $R_y(\theta)$ in terms of just $R_z(\theta)$ and Clifford gates. It is easy to see that the same is true for $R_x(\theta)$.

We implement a Clifford + $T$ gate approximation of $R_z(\theta)$ using the \texttt{gridsynth} package~\cite{10.5555/3179330.3179331}, which takes in an angle $\theta$ and a precision $\epsilon$ and computes a decomposition for $R_z(\theta)$ with a $T$-gate count within $O(\log(\log(1/\epsilon)))$ of optimal.

This allows us to modularly use the $R_x$, $R_y$, and $R_z$ gates, noting that they are the most expensive operation, so we should aim to minimize their usage.

\subsection{Exponential of a Pauli String}
We next tackle the implementation of $\exp(i\frac{\pi}{7} ZZ)$. We can observe that 
\begin{equation}
\exp(i\theta ZZ) = CX (I \otimes \exp(i\theta Z)) CX.
\end{equation}
Consider the $R_z$ gate, which is defined as
\begin{equation}
	R_z(\theta) = \begin{bmatrix}
 	e^{-i\frac{\theta}{2}} & 0 \\
	0 & e^{i\frac{\theta}{2}}
 \end{bmatrix}.
\end{equation}
It is not hard to see that $\exp(i\theta Z)=R_z(-2\theta)$. Therefore, we can implement this unitary similarly to the previous one but using only one $R_z$ gate.

\subsection{Exponential of a Hamiltonian}
Consider the unitary operator $\exp(i\frac{\pi}{7}H_1)$, where $H_1=XX+YY$. We implement each summand separately in a construction is similar to above. We implement $\exp(i \frac{\pi}{7} XX)$ by taking the previous circuit and conjugating with $H$, and we implement $\exp(i \frac{\pi}{7} YY)$ by conjugating with $HS$ and $S^\dagger H$ on both qubits. This allows us to implement the exponential of this Hamiltonian using only two $R_z$ gates.

\subsection{A Curiously Simple Hamiltonian}
Suppose we consider a similar Hamiltonian to the one above, but with a slightly different construction. We consider $\exp(i\frac{\pi}{4}H_2)$, where $H_2=XX+YY+ZZ$. Can we implement this operator more efficiently than the previous ones?

It turns out that we can, using the SWAP gate, which is defined as
\begin{equation}
	\text{SWAP} = \frac{1}{2}(II+XX+YY+ZZ).
\end{equation}
Using the SWAP gate, we can rewrite our exponential as
\begin{align}
	\exp\left(i\frac{\pi}{4}H_2\right) &= \exp\left(i\frac{\pi}{4}(2\text{SWAP}-I)\right) \\
	&= e^{-i\frac{\pi}{4}}\exp\left(i\frac{\pi}{2}\text{SWAP}\right) \\
	&= e^{i\frac{\pi}{4}}\text{SWAP}
\end{align}
where the coefficient is a global phase that we can discard. Therefore, the Hamiltonian exponential is equivalent to the SWAP gate, which we can easily write using three CNOTs by the XOR swap algorithm:
\begin{equation}
	\begin{quantikz}
		\lstick{$q_0$} &\ctrl{1}&\targ{}&\ctrl{1}& \\
		\lstick{$q_1$} &\targ{}&\ctrl{-1}&\targ{}&
	\end{quantikz}
\end{equation}
This form makes the Hamiltonian trivial to simulate.

\subsection{Two-Qubit Transverse Field Ising Model}
We construct this exponential operator, defined as $\exp(i\frac{\pi}{7}H_3)$, where $H_3=XX+ZI+IZ$. We construct the $XX$ term in the same way as described in Sec. 3.4. For the other two terms, we simply apply $R_z(-2\theta)$ to each qubit.

\subsection{State Preparation}
We now discuss the implementation of an arbitrary state preparation
\begin{equation}
\begin{aligned}
	|00\rangle \mapsto (0.1061479384-0.679641467i)&|00\rangle \\
	+ (-0.3622775887-0.453613136i)&|01\rangle \\
	+ (0.2614190429+0.0445330969i)&|10\rangle \\
	+ (0.3276449279-0.1101628411i)&|11\rangle.
\end{aligned}
\end{equation}
This task differs from the previous ones since it is totally random. There is no structure we can exploit to systematically minimize the number of $T$ gates we're using.

Consider how this unitary operator might look. For a unitary operator $U$ where 
\begin{equation}
	U|00\rangle = \alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle,
\end{equation}
its structure in the computational basis would be reminiscent of the following:
\begin{equation}
	U = \begin{bmatrix}
0.1061479384-0.679641467i & * & * & * \\
-0.3622775887-0.453613136i  & * & * & * \\
0.2614190429+0.0445330969i & * & * & * \\
0.3276449279-0.1101628411i & * & * & *
\end{bmatrix}
\end{equation}
where the $*$ symbols depict ``free variables'' that we don't care about the specific values of. The key observation is that for this matrix to be unitary, these columns must form an orthonormal basis, and the specific values of these free variables will greatly affect the number of $T$ gates.

Therefore, our protocol is the following: we first generate a complete unitary using the Gram-Schmidt process, encoding randomness on many different diagonal matrices that are applied to each sample unitary. We then test each candidate unitary over many different values of $\epsilon$. To balance the tradeoff, we start with a fidelity threshold compared to the expected state, and once that is hit, we then test over $\epsilon$ to minimize the number of $T$ gates.

More precisely, we transpile the circuit into rotation gates using \texttt{qiskit}, and then decompose each one with a different most optimized $\epsilon$ value by comparing individually to the fidelity of the state with that operator applied as well as its individual $T$ gate count.

This approach allows us to get a highly optimized circuit without incorporating any sort of structural symmetry; our approach works on fully random state preparation instances.

\subsection{A Structured Unitary}
We aim to apply the unitary
\begin{equation}
	U_1 = \frac{1}{2}\begin{bmatrix}
 	1 & 1 & 1 & 1 \\
 	1 & i & -1 & -i \\
 	1 & -1 & 1 & -1 \\
 	1 & -i & -1 & i
 \end{bmatrix}.
\end{equation}
Notice that this unitary is the two-qubit quantum Fourier transform\cite{RossSelinger2014OptimalAncillaFree}. Since it only requires $z$ rotations that are multiples of $\frac{\pi}{4}$, we do not need any rotation gates. Our implementation uses only three $T$ gates.

\subsection{Another Structured Unitary}
Placeholder

\subsection{Random Unitary}
In the case of a random unitary operator, we can just use the exact same protocol as in Sec. 3.7 but without the generation of the unitary, since we are already restricted to what the unitary needs to be. Similarly to the state preparation problem, this approach gives us an efficient circuit without exploiting any structure relating to the unitary.

\subsection{Four-Qubit Diagonal Unitary}
Placeholder

\section{Simulations}
Given the intrinsic tradeoff between $T$-gate count and approximation accuracy, our research investigated different optimization regimes for various target operators. For unitaries $2, 3, 4, 6, 7,$ and $10$, we utilized a modular strategy where the circuit's total $T$-count was primarily determined by the precision ($\epsilon$) of our $R_z(\theta)$ gate decompositions.
\subsection{Unitary 2}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.48\textwidth]{unitary_2_distance_vs_tcount.png}
	\caption{T-count vs. distance tradeoff for Unitary 2.}
	\label{fig:unitary2}
\end{figure}
Figure 1 depicts varying epsilon values for Unitary 2. The plot for Unitary 2 exhibits a non-monotonic "spike" in error, where the distance reaches a maximum of $4.56 \times 10^{-1}$ at mid-range T-counts due to local optimization failures. As the gate budget increases to 200, the approximation stabilizes at a persistent plateau of $4.46 \times 10^{-1}$, indicating that further T-gates do not significantly improve fidelity for this specific rotation.

\subsection{Unitary 3}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.48\textwidth]{unitary_3_distance_vs_tcount.png}
	\caption{T-count vs. distance tradeoff for Unitary 3.}
	\label{fig:unitary3}
\end{figure}
Figure 2 depicts varying epsilon values for Unitary 3. Unitary 3 demonstrates a successful exponential decrease in error, with the distance dropping from $7.62 \times 10^{-2}$ down to a high-precision value of $1.38 \times 10^{-10}$. The profile features a distinct "breakthrough" near a T-count of 98, where the algorithm identifies an optimal Clifford+T sequence that dramatically reduces the residual error.

\subsection{Unitary 4}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.48\textwidth]{unitary_4_distance_vs_tcount.png}
	\caption{T-count vs. distance tradeoff for Unitary 4.}
	\label{fig:unitary4}
\end{figure}
Figure 3 depicts varying epsilon values for Unitary 4. This operator follows a steady downward trend punctuated by a significant error plateau between T-counts of 100 and 180. Upon reaching a budget of 196 gates, the distance collapses from roughly $10^{-5}$ to $1.96 \times 10^{-10}$, proving that higher T-gate thresholds are sometimes necessary to unlock high-precision approximations.

\subsection{Unitary 6}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.48\textwidth]{unitary_6_distance_vs_tcount.png}
	\caption{T-count vs. distance tradeoff for Unitary 6.}
	\label{fig:unitary6}
\end{figure}
Figure 4 depicts varying epsilon values for Unitary 6. Unitary 6 shows a rapid initial error reduction that quickly hits a hard ceiling, with the distance settling at $6.97 \times 10^{-1}$ despite increasing the T-count to nearly 300. This behavior suggests a structural mismatch where the specific target unitary remains mathematically distant from the gate sequences reachable within the current search depth.

\subsection{Unitary 7}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.48\textwidth]{unitary7_plot.png}
	\caption{T-count vs. distance tradeoff for Unitary 7.}
	\label{fig:unitary7}
\end{figure}
Figure 5 depicts varying epsilon values for Unitary 7. The plot for Unitary 7 monitors Fidelity instead of distance, specifically tracking performance within an extremely narrow, high-precision band between 0.9999990 and 1.0. The results show a highly unstable, oscillatory pattern between T-counts of 490 and 592, which reflects the randomized search protocol used to satisfy the strict target fidelity threshold of $\geq$ 0.999999. This high gate cost and non-linear behavior are characteristic of "totally random" state preparations that lack structural symmetries, requiring a brute-force exploration of the Clifford + T space to maintain near-perfect accuracy.

\subsection{Unitary 10}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.48\textwidth]{unitary_10_distance_vs_tcount.png}
	\caption{T-count vs. distance tradeoff for Unitary 10.}
	\label{fig:unitary10}
\end{figure}
Figure 6 depicts varying epsilon values for Unitary 10. Unitary 10 requires a much larger resource budget, scaling from 250 to over 700 gates to achieve a precision of $1.0 \times 10^{-3}$. The log-log linear trend, despite a minor local instability at 350 gates, confirms that this "random" operator demands high gate density to achieve even moderate fidelity compared to more structured gates.

\bibliographystyle{unsrt}
\bibliography{main}
\end{document}